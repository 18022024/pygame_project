from collections import deque
import sys
import game
matrix = [['#', '#', '#', '#', '#', '#', '#', '#', '#', '#', '#', '#', '#', '#', '#', '#', '#', '#', '#', '#', '#', '#', '#', '#', '#', '#', '#'],
          ['#', '#', '#', '#', '#', '#', '#', '#', '#', '#', '#', '#', '#', '#', '#', '#', '#', '#', '#', '#', '#', '#', '#', '#', '#', '#', '#'],
          ['#', '#', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '#', '#', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '#', '#'],
          ['#', '#', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '#', '#', '.', '.', '.', '.', '.', '.', '.', '!', '.', '.', '.', '#', '#'],
          ['#', '#', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '#', '#', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '#', '#'],
          ['#', '#', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '#', '#', '.', '.', '.', '.', '.', '.', '.', '.', '#', '#', '#', '#', '#'],
          ['#', '#', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '#', '#', '.', '.', '.', '.', '.', '.', '.', '.', '#', '#', '#', '#', '#'],
          ['#', '#', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '$', '$', '#', '#'],
          ['#', '#', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '#', '#', '.', '.', '.', '.', '$', '$', '#', '#'],
          ['#', '#', '.', '.', '.', '.', '#', '#', '#', '#', '#', '.', '.', '.', '.', '.', '.', '#', '#', '.', '.', '.', '#', '#', '#', '#', '#'],
          ['#', '#', '.', '.', '.', '.', '#', '#', '#', '#', '#', '.', '.', '.', '.', '.', '.', '#', '#', '.', '.', '.', '#', '#', '#', '#', '#'],
          ['#', '#', '.', '.', '.', '.', '#', '#', '.', '.', '.', '.', '.', '.', '.', '.', '.', '#', '#', '.', '.', '.', '.', '.', '.', '#', '#'],
          ['#', '#', '.', '.', '.', '.', '#', '#', '*', '.', '.', '.', '.', '.', '.', '.', '.', '#', '#', '.', '.', '.', '.', '.', '.', '#', '#'],
          ['#', '#', '#', '#', '#', '#', '#', '#', '#', '#', '#', '#', '#', '#', '#', '#', '#', '#', '#', '#', '#', '#', '#', '#', '#', '#', '#'],
          ['#', '#', '#', '#', '#', '#', '#', '#', '#', '#', '#', '#', '#', '#', '#', '#', '#', '#', '#', '#', '#', '#', '#', '#', '#', '#', '#']]

from collections import deque


def is_valid(x, y, matrix, visited):
    # Проверяем, находится ли клетка в границах матрицы и не является ли она препятствием или уже посещенной
    return 0 <= x < len(matrix) and 0 <= y < len(matrix[0]) and matrix[x][y] != '#' and not visited[x][y]


def bfs(matrix, start, end):
    rows, cols = len(matrix), len(matrix[0])
    visited = [[False for _ in range(cols)] for _ in range(rows)]

    # Список направлений для движения (вверх, вниз, влево, вправо)
    directions = [(-1, 0), (1, 0), (0, -1), (0, 1)]

    queue = deque([(start, [start])])  # очередь для BFS и путь
    visited[start[0]][start[1]] = True

    while queue:
        (curr_x, curr_y), path = queue.popleft()

        # Если достигли конечной точки, возвращаем путь
        if (curr_x, curr_y) == end:
            return path

        for dx, dy in directions:
            new_x, new_y = curr_x + dx, curr_y + dy

            if is_valid(new_x, new_y, matrix, visited):
                visited[new_x][new_y] = True
                queue.append(((new_x, new_y), path + [(new_x, new_y)]))

    return []  # если путь не найден


def find_start_and_end(matrix):
    start = end = None
    for i in range(len(matrix)):
        for j in range(len(matrix[0])):
            if matrix[i][j] == '!':
                start = (i, j)
            elif matrix[i][j] == '@':
                end = (i, j)
    return start, end


# Пример использования:
matrix = [['#', '#', '#', '#', '#', '#', '#', '#', '#', '#', '#', '#', '#', '#', '#', '#', '#', '#', '#', '#', '#', '#', '#', '#', '#', '#', '#'],
          ['#', '#', '#', '#', '#', '#', '#', '#', '#', '#', '#', '#', '#', '#', '#', '#', '#', '#', '#', '#', '#', '#', '#', '#', '#', '#', '#'],
          ['#', '#', '@', '.', '.', '.', '.', '.', '.', '.', '.', '.', '#', '#', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '#', '#'],
          ['#', '#', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '#', '#', '.', '.', '.', '.', '.', '.', '.', '!', '.', '.', '.', '#', '#'],
          ['#', '#', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '#', '#', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '#', '#'],
          ['#', '#', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '#', '#', '.', '.', '.', '.', '.', '.', '.', '.', '#', '#', '#', '#', '#'],
          ['#', '#', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '#', '#', '.', '.', '.', '.', '.', '.', '.', '.', '#', '#', '#', '#', '#'],
          ['#', '#', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '$', '$', '#', '#'],
          ['#', '#', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '#', '#', '.', '.', '.', '.', '$', '$', '#', '#'],
          ['#', '#', '.', '.', '.', '.', '#', '#', '#', '#', '#', '.', '.', '.', '.', '.', '.', '#', '#', '.', '.', '.', '#', '#', '#', '#', '#'],
          ['#', '#', '.', '.', '.', '.', '#', '#', '#', '#', '#', '.', '.', '.', '.', '.', '.', '#', '#', '.', '.', '.', '#', '#', '#', '#', '#'],
          ['#', '#', '.', '.', '.', '.', '#', '#', '.', '.', '.', '.', '.', '.', '.', '.', '.', '#', '#', '.', '.', '.', '.', '.', '.', '#', '#'],
          ['#', '#', '.', '.', '.', '.', '#', '#', '*', '.', '.', '.', '.', '.', '.', '.', '.', '#', '#', '.', '.', '.', '.', '.', '.', '#', '#'],
          ['#', '#', '#', '#', '#', '#', '#', '#', '#', '#', '#', '#', '#', '#', '#', '#', '#', '#', '#', '#', '#', '#', '#', '#', '#', '#', '#'],
          ['#', '#', '#', '#', '#', '#', '#', '#', '#', '#', '#', '#', '#', '#', '#', '#', '#', '#', '#', '#', '#', '#', '#', '#', '#', '#', '#']]

start, end = find_start_and_end(matrix)
print(start, end)
if start and end:
    answer = list()
    path = bfs(matrix, start, end)
    for i in range(1, len(path)):
        if path[i - 1][0] - path[i][0] < 0:
            answer.append('down')
        elif path[i - 1][0] - path[i][0] > 0:
            answer.append('up')
        elif path[i - 1][1] - path[i][1] > 0:
            answer.append('left')
        elif path[i - 1][1] - path[i][1] < 0:
            answer.append('right')
    print(answer)
else:
    print("Начальная или конечная позиция не найдена.")
